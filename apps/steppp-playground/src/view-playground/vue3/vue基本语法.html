<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <script src="https://unpkg.com/vue@next"></script>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      body {
        width: 800px;
        margin-left: 20%;
      }
      .red {
        color: red;
      }
      .blue {
        color: blue;
      }
    </style>
  </head>
  <body>
    <div id="app">
      注意： " "里面 或者
      大括号里面只能写表达式，不可以写语句，也就是不能出现“;”
      <br />
      var a = 1 或者 if (ok) { return message } 也是不行的，不过可以用三元表达式
      <br /><br />

      msg : {{msg}}
      <br /><br />

      v-html: <span v-html="msg"></span> <br /><br />

      v-once: <span v-once>{{msg}}</span> <br /><br />

      v-model :
      <label for="r1">修改颜色</label
      ><input type="checkbox" v-model="disable" id="r1" /><br /><br />

      v-bind:简写 “ : ”
      <button v-bind:class="{'red': disable}">红红红</button>
      <button v-bind:class="class1">蓝蓝蓝</button>
      <br /><br />

      v-if: 还有v-else v-else-if
      <p v-if="seen">现在你看到我了</p>
      根据type是啥显示A或B或C或Not A/B/C，type的值：<input v-model="type" />
      <div v-if="type === 'A'">A</div>
      <div v-else-if="type === 'B'">B</div>
      <div v-else-if="type === 'C'">C</div>
      <div v-else>Not A/B/C</div>
      <br /><br />

      v-for 、 template标签<br />
      迭代数组:
      <ol>
        <template v-for="fruit,index in fruits">
          <li>index:{{index}}; id: {{fruit.id}}; name : {{ fruit.name }}</li>
        </template>
      </ol>

      迭代对象:
      <ul>
        <li v-for="value,key,index in pen">
          index: {{index}}; key:{{ key }}; val:{{value}};
        </li>
      </ul>

      迭代整数：
      <ul>
        <li v-for="n in 3">{{ n }}</li>
      </ul>
      <br /><br />

      v-on : 简写 @ <br />
	  <span v-html="msg"></span>
      <button v-on:click="reverseMessage">反转字符串</button>
      <br /><br />

      v-show :
      <h1 v-show="ok">Hello!</h1>
      <br /><br />

      select标签：
      <select @change="changeVal($event)" v-model="selOption">
        <template
          v-for="(site,index) in sites"
          :site="site"
          :index="index"
          :key="site.id"
        >
          <!-- 索引为 1 的设为默认值，索引值从0 开始-->
          <option v-if="index == 1" :value="site.name" selected>
            {{site.name}}
          </option>
          <option v-else :value="site.name">{{site.name}}</option>
        </template>
      </select>
      <div>您选中了:{{selOption}}</div>
      <br /><br />

      一个todolist demo，全局组件
      <div id="todo-list-example">
        <form v-on:submit.prevent="addNewTodo">
          <label for="new-todo">添加 todo</label>
          <input
            v-model="newTodoText"
            id="new-todo"
            placeholder="例如：明天早上跑步"
          />
          <button>添加</button>
        </form>
        <ul>
          <todo-item
            v-for="(todo, index) in todos"
            :key="todo.id"
            :title="todo.title"
            @remove="todos.splice(index, 1)"
          ></todo-item>
        </ul>
      </div>
      <br /><br />

      局部组件：
      <runoob-a></runoob-a>
      <component-b></component-b>
      <br /><br />

      props校验： <br />当 prop 验证失败的时候，(开发环境构建版本的) Vue
      将会产生一个控制台的警告。 <br />type 可以是下面原生构造器： String Number
      Boolean Array Object Date Function Symbol<br />type
      也可以是一个自定义构造器，使用 instanceof 检测。

      <br /><br />

      computed vs methods<br />

      我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed
      是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods
      ，在重新渲染的时候，函数总会重新调用执行。<br />

      可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods
      属性。
      <br /><br />

      computed setter
      没啥大用，就是偷懒把，改一个值，动态影响其他多个值的时候可以用
      <br /><br />

      事件修饰符<br />
      Vue.js 为 v-on 提供了事件修饰符来处理 DOM
      事件细节，如：event.preventDefault() 或 event.stopPropagation()。
      <!-- 阻止单击事件冒泡 -->
      <a v-on:click.stop="doThis"></a>
      <!-- 提交事件不再重载页面 -->
      <form v-on:submit.prevent="onSubmit"></form>
      <!-- 修饰符可以串联  -->
      <a v-on:click.stop.prevent="doThat"></a>
      <!-- 只有修饰符 -->
      <form v-on:submit.prevent></form>
      <!-- 添加事件侦听器时使用事件捕获模式 -->
      <div v-on:click.capture="doThis">...</div>
      <!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
      <div v-on:click.self="doThat">...</div>

      <!-- click 事件只能点击一次，2.1.4版本新增 -->
      <a v-on:click.once="doThis"></a>
      <!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
      <input v-on:keyup.13="submit" />
      <!-- 同上 -->
      <input v-on:keyup.enter="submit" />
      <!-- 缩写语法 -->
      <br /><br />
      <input @keyup.enter="submit" />
      <br /><br />

      全部的按键别名： .enter .tab .delete (捕获 "删除" 和 "退格" 键) .esc
      .space .up .down .left .right
      <br /><br />
      系统修饰键： .ctrl .alt .shift .meta
      <br /><br />
      鼠标按钮修饰符: .left .right .middle
      <br /><br />

      表单；在文本区域 textarea 插值是不起作用，需要使用 v-model 来代替：

      <!-- 错误 -->
      <textarea>{{ text }}</textarea>

      <!-- 正确 -->
      <textarea v-model="text"></textarea>
      <br /><br />

      钩子函数、生命周期 beforeCreate created beforeMount mounted ( beforeUpdate
      updated ) beforeDestroy destroyed
      <br /><br />

      路由
      <br /><br />

      axios
      <br /><br />

      setup、ref、reactive<br />
      <br /><br />

      <br /><br />

      <br /><br />

      <br /><br />

      <br /><br />

      <br /><br />

      <br /><br />

      <br /><br />
    </div>
    <!-- -------------------------------------------------------------- -->
    <!-- -------------------------------------------------------------- -->
    <!-- -------------------------------------------------------------- -->
    <script>
      // 声明局部组件，一定要在带入主组件之前声明好
      const runoobA = {
        template: "<h1>自定义组件!</h1>",
      };
      const ComponentB = {
        template: "<h1>自定义组件BBB!</h1>",
      };

      const app = Vue.createApp({
        components: {
          "runoob-a": runoobA,
          "component-b": ComponentB,
        },
        data() {
          return {
            msg: "123",
            class1: "blue",
            disable: true,
            seen: true,
            fruits: [
              { id: 1, name: "apple" },
              { id: 2, name: "banana" },
            ],
            type: "C",
            ok: true,
            pen: {
              size: 15,
              color: "red",
            },
            selOption: "Runoob",
            sites: [
              { id: 1, name: "Google" },
              { id: 2, name: "Runoob" },
              { id: 3, name: "Taobao" },
            ],
            newTodoText: "",
            todos: [
              {
                id: 1,
                title: "看电影",
              },
              {
                id: 2,
                title: "吃饭",
              },
              {
                id: 3,
                title: "上 RUNOOB 学习",
              },
            ],
            nextTodoId: 4,
          };
        },
        computed: {},
        methods: {
          changeMsg() {
            this.msg = "changed135";
          },

          reverseMessage() {
            this.msg = this.msg.split("").reverse().join("");
          },
          changeVal(event) {
            this.selOption = event.target.value;
            alert("你选中了" + this.selOption);
          },
          addNewTodo() {
            this.todos.push({
              id: this.nextTodoId++,
              title: this.newTodoText,
            });
            this.newTodoText = "";
          },
        },
        watch: {
          // 每当问题改变时，此功能将运行，以 ? 号结尾
          question(newQuestion, oldQuestion) {
            if (newQuestion.indexOf("?") > -1) {
              this.getAnswer();
            }
          },
          cityName: {
            handler(newName, oldName) {
              // ...
            },
            deep: true,
            // 当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行。
            // 如果我们需要在最初绑定值得时候也执行函数，则就需要用到immediate属性。
            immediate: true,
          },
          "cityName.name": {
            handler(newName, oldName) {
              // ...
            },
            deep: true,
            immediate: true,
          },
        },
      });

      // 全局注册的组件
      // 可以在随后创建的 app 实例模板中使用，也包括根实例组件树中的所有子组件的模板中。。
      app.component("todo-item", {
        template: `
                <li>
                {{ title }}
                <button @click="$emit('remove')">删除</button>
                </li>
            `,
        props: ["title"],
        emits: ["remove"],
      });
      app.component("my-component", {
        props: {
          // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
          propA: Number,
          // 多个可能的类型
          propB: [String, Number],
          // 必填的字符串
          propC: {
            type: String,
            required: true,
          },
          // 带有默认值的数字
          propD: {
            type: Number,
            default: 100,
          },
          // 带有默认值的对象
          propE: {
            type: Object,
            // 对象或数组默认值必须从一个工厂函数获取
            default: function () {
              return { message: "hello" };
            },
          },
          // 自定义验证函数
          propF: {
            validator: function (value) {
              // 这个值必须匹配下列字符串中的一个
              return ["success", "warning", "danger"].indexOf(value) !== -1;
            },
          },
        },
      });

      const vm = app.mount("#app");

      // init data
      vm.$data.msg = "456";
      vm.msg = "789";

      vm.changeMsg();
    </script>
  </body>
</html>
